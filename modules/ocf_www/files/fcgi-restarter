#!/usr/bin/env python3

import fnmatch
import logging
import os
import psutil
import re
import time
from textwrap import dedent
from traceback import format_exc

from ocflib.account.utils import web_dir
from ocflib.misc.mail import send_problem_report

FCGI_REGEX = re.compile('.+\.fcgi')
ATTRS = ('pid', 'username', 'cwd', 'cmdline')
LOG_FILE = '/var/log/apache2/fcgi-restarter.log'


if __name__ == '__main__':
    try:
	# This is used to persist data between iterations to keep track of the
        # processes and files that should be watched
        fcgi_processes = {}

	# This is used so that any processes that die naturally are removed
        # properly from the fcgi_processes dictionary
        current_pids = set()

        logger = logging.getLogger('fcgi-restarter')
        file_logger = logging.FileHandler(LOG_FILE)
        console_logger = logging.StreamHandler()

        formatter = logging.Formatter('%(asctime)s - %(name)s - %(message)s')
        file_logger.setFormatter(formatter)
        console_logger.setFormatter(formatter)

        logger.addHandler(file_logger)
        logger.addHandler(console_logger)
        logger.setLevel(logging.DEBUG)

        while True:
            # TODO: Switch to using attrs filter for process_iter after psutil version 5.3
            # is installed (likely buster, or stretch-backports)
            for process in psutil.process_iter():
                try:
                    pinfo = process.as_dict(ATTRS, ad_value='')
                except psutil.NoSuchProcess:
                    continue

                # We don't care about processes running as root or www-data and shouldn't
                # touch them anyway
                if pinfo['username'] in ['root', 'www-data']:
                    continue

                pid = pinfo['pid']
                matches = [FCGI_REGEX.match(elem) for elem in pinfo['cmdline']]
                if any(matches):
                    current_pids.add(pid)
                    if pid not in fcgi_processes:
                        fcgi_file = [match for match in matches if match][0].group(0)
                        assert(fcgi_file.endswith('.fcgi'))

                        fcgi_processes[pid] = {'time': None}

                        # If the working directory has *not* been changed from their
                        # directory in /services/http/users/, just watch the fcgi file in
                        # that directory for any modifications
                        if pinfo['cwd'].startswith(web_dir(pinfo['username'])):
                             fcgi_processes[pid]['paths'] = ['{}/{}'.format(pinfo['cwd'], fcgi_file)]
                        else:
                            # Switch to glob.glob with recursive=True once on Python 3.5 (stretch):
                            # fcgi_paths = glob.glob('{}/**/{}'.format(web_dir(pinfo['username']), fcgi_file), recursive=True)
                            fcgi_processes[pid]['paths'] = []
                            for root, dirnames, filenames in os.walk(web_dir(pinfo['username'])):
                                for filename in fnmatch.filter(filenames, fcgi_file):
                                    fcgi_processes[pid]['paths'].append(os.path.join(root, filename))

                    modify_times = []
                    for fcgi_path in fcgi_processes[pid]['paths']:
                        try:
                            modify_times.append(os.path.getmtime(fcgi_path))
                        except FileNotFoundError:
                            pass

                    if modify_times:
                        modify_time = max(modify_times)

                        if not fcgi_processes[pid]['time']:
                            fcgi_processes[pid]['time'] = modify_time

                        # Kill off fcgi script since it has been modified (or touched)
                        # more recently
                        if modify_time > fcgi_processes[pid]['time']:
                            logger.warn(
                                'Killing off {}, owned by user {} from refresh on {}'.format(
                                    pid,
                                    pinfo['username'],
                                    fcgi_processes[pid]['paths'],
                                 )
                            )
                            process.terminate()
                        else:
                            # TODO: Remove this when not needed any more
                            logger.debug('PID: {}\t User: {}\t Modified: {}\t Cwd: {}\t Paths: {}'.format(
                                pid,
                                pinfo['username'],
                                modify_time,
                                pinfo['cwd'],
                                fcgi_processes[pid]['paths'],
                            ))

	    # Clear up old PIDs from fcgi_processes when old processes exit,
            # whether they are killed by this process or by apache2
            dead_processes = set(fcgi_processes.keys()).difference(current_pids)
            current_pids = set()
            if dead_processes:
                logger.info("Dead processes since last iteration, removing: {}".format(dead_processes))
                for pid in dead_processes:
                    del fcgi_processes[pid]

            logger.debug(fcgi_processes)
            time.sleep(5)
    except Exception:
        msg = dedent("""\
            fcgi-restarter encountered the following error:
            {traceback}
        """).format(traceback=format_exc())

        send_problem_report(msg)
